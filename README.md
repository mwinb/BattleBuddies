## An Exploration into Flutter and Background Processes. 
   Battle Buddies is an application designed to send reminders to a user to check in. Clicking on the reminder will either send a check in message with their current location or allow a user to send a check in message with or without gps based on the type of check in they choose. 

## Plugins: 
- [sms](https://pub.dev/packages/sms)
- [sqflite](https://pub.dev/packages/sqflite)
- [path](https://pub.dev/packages/path)
- [flutter_local_notifications](https://pub.dev/packages/flutter_local_notifications)
- [geolocator](https://pub.dev/packages/geolocator)
- [contact_picker](https://pub.dev/packages/contact_picker)
- [cupertino_icons](https://pub.dev/packages/cupertino_icons)

## Abstract
As a student and junior software developer, I decided to explore developing an application that makes use of background processes to send sms alerts to a chosen contact based on a designated interval. For this project I decided to use Flutter in an attempt to create simple cross platform functionality. I chose Flutter based on a prior [space news application](https://github.com/mwinb/scottyFlutter) that I created and the simplicity Flutter brought to that project. Prior to taking my course in Java Android development many students, me included, were of the opinion that we should be learning a more "modern framework" such as Flutter or React Native instead of Android with Java. While these newer frameworks have wide use cases in the modern web based world, due to the challenges faced while working on this project, I have changed my mind about the importance of native Android development with Java. Flutter development, in its simplest form, is based around the Dart language, widgets, and plugins. By taking advantage of the many pre-built Material UI widgets, darts simple syntax, and elegant state management, Flutter is an ideal tool to create a CRUD based mobile web application that can interface easily with other tools such as Firebase. When faced with executing background processes and interfacing directly with the Android system, I found that the simplicity of Flutters framework quickly lost its ease of use for an inexperienced mobile developer such as myself. Flutter uses Dart Isolates to create background services. The Flutter API points a user interested in creating background processes to a [Medium article](https://medium.com/flutter/executing-dart-in-the-background-with-flutter-plugins-and-geofencing-2b3e40a1a124) about creating a geofencing application using dart isolates. While this article is thorough and will teach a reader the ends and outs of creating a geofencing application on their own, the focus on background development is severly lacking. Attempting to decode the background processes portion from this article has led many users to leave comments and projects of their own to attempt to decipher what has been lost in a clutter of geofencing specific execution. One user whom took it upon themselves to create a more clear and simple implementation commented that "[he] read this article 10 times and 26 hours later (literally) [he] finally wrapped [his] head around this concept..." and provided a very helpful github link with his [example](https://github.com/charleswritescode/flutter_background_code). My experience was very similar until I found his example. From my research I quickly found that implementing a background service to send sms messages was not going to be simple. Based on my introductory knowledge of Dart Isolates, these isolates run on a separate thread of execution from the main application. The isolate then can be configured to communicate with the primary application using channels to send messages and data between the isolate and main application, but only if the main application is up and running. If a developer has any experience with web workers they will likely find the implementation, use case, and execution very similar to Dart Isolates. This is where I came to an important crossroad. I had to chose to write my own wrapper and plugin using the native implementation of the Android [Alarm Manager](https://developer.android.com/reference/android/app/AlarmManager) and [Android SMS](https://developer.android.com/reference/android/telephony/SmsManager) or find a Flutter plugin that using the previous method already has the desired functionality. This is where I ran into my second primary issue with the Flutter framework. Flutter is very new. Many of the plugins, while being created recently, have already been deprecated or are now no longer maintained. Due to the time constraints of the this project I decided to make use of already built plugins in an attempt to provide, at the least, usable functionality and a completed application. I started by going to the [android_alarm_manger plugin](https://pub.dev/packages/android_alarm_manager) while this plugin seemed to be the answer I was looking for, I quickly realized that I was going to be limited to top level functions and would not maintain the necessary state and configuration to make use of the [sms](https://pub.dev/packages/sms). After working my way through many other plugins that have their own specific implementations and use cases for executing background processes, primarily fetching data from a web api, I settled on a change of requirements and went with the [flutter_local_notifications](https://pub.dev/packages/flutter_local_notifications) plugin so that I could maintain my desired functionality with some additional user interaction. This is where my new found opinion of the importance of learning the native mobile languages such as Java for Android and objective C for iOS. While Flutter truly does simplify mobile application development, when a developer is faced with a situation where they need to implement a very specific use case, if they lack the knowledge of native programming, they will not only struggle to find a solution, but when they do realize that solution is to write native code, they will also struggle with finding and implementing that solution. While I was not able to create a custom plugin due to time constraints, without having learned the basics of native Android development I may not have ever realized that a solution, while still taking advantage of Flutters strong points, even existed. As a software developer there is a certain temptation to jump into frameworks and libraries that abstract away the underlying functionality, but without a fundamental understanding of the underlying platform a developer limits their capabilities to the implementations and use cases that others have created.  
